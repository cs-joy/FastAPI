# Middleware
# # source: https://fastapi.tiangolo.com/tutorial/middleware/
# # stackoverflow: https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class

'''
We can add middleware to FastAPI applications.

A "middleware" is a function that works with every "request" before it is processed by 
any specific path operation. And also with every response before returning it. 

- It takes each request that comes to our applicaton.
- It can then do something to that request or run any needed code.
- Then it passes the request to be processed by the rest of the application (by some path operation).
- It then takes the response generated by the application (by some path operation).
- It can do something to that response or run any needed code.
- Then it returns the response.
'''

# # Technical details # #
# If we have dependencies with `yield`, the exit code will run after the middleware.
# If there were any background tasks (covered in the Background Tasks(see APPENDIX: A(towards of the end of the file))
# section,) they will run after the middleware

# # Create middleware
'''
To create a middleware we use the decorator `@app.middleware("http")` on top of a function.

The middleware function receives:
- The `request`
- A function `call_next` that will receives the `request` as a parameter.
    - This function will pass the `request` to the corresponding path operation.
    - Then it returns the `response` generated by the corresponding path operation.

- We can then further modify the `response` before returning it.
'''

import time
from fastapi import FastAPI, Request, Response
from fastapi.middleware.cors import CORSMiddleware
#from starlette.requests import Request

app = FastAPI()
subapi = FastAPI()

origins = ['http://localhost:3001']  

subapi.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=False,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.middleware("http")
async def first_middleware(request: Request, call_next) -> Response:
    start_time = time.perf_counter()
    response = await call_next(request)
    process_time = time.perf_counter() - start_time
    text_inject_into_header = "hello world"
    response.headers["X-Process-Time"] = str(process_time)
    response.headers["X-Test"] = str(text_inject_into_header)
    return response

@app.middleware("http")
async def second_middleware(request: Request, call_next):
    token = '5-sdf-45-g-fg-e-6-456-gdfgdf6t56-456-4564'
    response = await call_next(request)
    response.headers['hidden-token'] = str(token)
    return response

# TIP::::
# Keep in mind that custom propretary headers can be added using the `X-` prefix: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers
# But if we have custom headers that we want a client in a browser to be able to see, we need to add them to our CORS configurations (CORS(Cross-Origin Resource Sharing)): https://fastapi.tiangolo.com/tutorial/cors/
# using the parameter `expose_headers` documented in "Starlette's CORS docs: https://www.starlette.dev/middleware/#corsmiddleware"

# Technical details:
# We could also use `from starlette.requests import Request`

# # Before and after the `response`
# We can add code to be run with the `request`, before any path operation receives it.
# And also after the `response` is generated, before returning it.
# For example, we could add a custom header `X-Process-Time` containing the time in seconds that 
# it took to process the request and generate a response:

# `response.headers["X-Process-Time"] = str(process_time)`

@app.get('/middleware/')
async def explore_middleware():
    return  'Hello middleware!'

# # Multiple middleware execution order
'''
When we add multiple middleware using either `@app.middleware()` decorator or `app.add_middleware()` method,
each new middleware wraps the application, forming a stack. The last middleware added is the outermost,
and the first is the innermost.

On the request path, the outermost middleware runs first.
On the response path, it runs the last.

For example:
```
app.add_middleware(MiddlewareA)
app.add_middleware(MiddlewareB)
```
This results in the following execution order:
- Request: MiddlewareB -> MiddlewareA -> route
- Response: route -> MiddlewareA -> MiddlewareB

# in our own example scenario:
- Requst: second_middleware -> first_middleware -> route


This stacking behaviour ensures that middlewares are executed in a predictable and controllable order.
'''

# # other middleware
# To read more about other middleware please follow "Advanced User Guide: Advanced Middleware" chapter: https://fastapi.tiangolo.com/advanced/middleware/
# We will read about how to handle CORS with a middleware in the next section.


@subapi.get('/subapi-hello/')
async def subapi_hello():
    return "hi :)"
    
app.mount('/subapi', subapi)

'''
APPENDIX A:

# Background Task:
We can define background tasks to be run after returning a response.
This is useful for operations that need to happen after a request, but that the client doesn't really have to be waiting for the operation to complete before receiving that response.
This includes, for example:
- Email notifications sent after performing an action:
    - As connecting to an email server and sending an email tends to be "slow" (several seconds), 
        we can return the response right away and send the email notification in the background.
- Processing data:
    - For example, let's say we receive a file that must go through a slow process, we can return a response of "Accepted(HTTP 202)" and process the file in the background.

....... learn more: https://fastapi.tiangolo.com/tutorial/background-tasks/
'''